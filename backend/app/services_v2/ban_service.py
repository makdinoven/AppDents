import ipaddress
import logging
import os
from typing import Optional, Tuple

import httpx
from fastapi import HTTPException
from sqlalchemy.orm import Session, selectinload

from ..models.models_v2 import BanEmail, BanIP
from ..utils.ip_utils import get_client_ip as _get_client_ip

logger = logging.getLogger(__name__)


def get_client_ip(request) -> str:
    # единая логика уже есть в utils.ip_utils
    return _get_client_ip(request)


def _norm_email(email: str | None) -> str | None:
    if not email:
        return None
    e = email.strip().lower()
    return e or None


def _norm_ip(ip: str | None) -> str | None:
    if not ip:
        return None
    raw = ip.strip()
    if not raw or raw.lower() == "unknown":
        return None
    try:
        addr = ipaddress.ip_address(raw)
    except ValueError:
        return None
    return str(addr)


def _ban_error_detail(email: str | None, ip: str | None, source: str) -> dict:
    return {
        "error": {
            "code": "BANNED",
            "message": "Access denied",
            "translation_key": "error.banned",
            "params": {"email": email, "ip": ip, "source": source},
        }
    }


def enforce_not_banned(
    db: Session,
    *,
    email: str | None,
    ip: str | None,
    source: str,
    created_by_admin_id: int | None = None,
) -> None:
    """
    Проверяет бан по email/IP. Если найден бан по одной стороне,
    добавляет вторую (если валидна) и связывает, затем выбрасывает 403.
    """
    email_n = _norm_email(email)
    ip_n = _norm_ip(ip)

    if not email_n and not ip_n:
        return

    ban_email = (
        db.query(BanEmail)
        .options(selectinload(BanEmail.ips))
        .filter(BanEmail.email == email_n)
        .first()
        if email_n
        else None
    )
    ban_ip = (
        db.query(BanIP)
        .options(selectinload(BanIP.emails))
        .filter(BanIP.ip == ip_n)
        .first()
        if ip_n
        else None
    )

    if not ban_email and not ban_ip:
        return

    ip_added = False
    changed = False

    # Если найден email, но IP нет — добавляем IP и линк
    if ban_email and not ban_ip and ip_n:
        ban_ip = BanIP(
            ip=ip_n,
            is_manual=False,
            created_by_admin_id=created_by_admin_id,
        )
        db.add(ban_ip)
        db.flush()
        ip_added = True
        changed = True

    # Если найден IP, но email нет — добавляем email и линк
    if ban_ip and not ban_email and email_n:
        ban_email = BanEmail(
            email=email_n,
            is_manual=False,
            created_by_admin_id=created_by_admin_id,
        )
        db.add(ban_email)
        db.flush()
        changed = True

    # Если есть обе стороны — создаём связь (если её нет)
    if ban_email and ban_ip:
        if ban_ip not in (ban_email.ips or []):
            ban_email.ips.append(ban_ip)
            changed = True

    if changed:
        db.commit()
        # обновляем nginx бан-файл только когда добавили/изменили IP-состав
        if ip_added:
            try:
                sync_nginx_ban_file_and_reload(db)
            except Exception as e:
                logger.exception("Failed to sync nginx ban file after auto-ban: %s", e)
    else:
        db.rollback()

    raise HTTPException(status_code=403, detail=_ban_error_detail(email_n, ip_n, source))


def _ban_file_path() -> str:
    return os.getenv("BAN_NGINX_FILE_PATH", "/nginx_runtime/ban_ips.conf")


def _reloader_url() -> str:
    return os.getenv("NGINX_RELOADER_URL", "http://nginx_reloader:9000")


def _reloader_token() -> str:
    return os.getenv("NGINX_RELOAD_TOKEN", "")

def _reload_required() -> bool:
    """
    Если включено, то при любой ошибке reload (включая отсутствие токена)
    будем падать, чтобы не создавать ложное ощущение «IP уже заблокирован на Nginx».
    По умолчанию выключено (dev-friendly).
    """
    return os.getenv("NGINX_RELOAD_REQUIRED", "0").strip().lower() in {"1", "true", "yes", "on"}


def _write_ban_file(ips: list[str]) -> None:
    path = _ban_file_path()
    os.makedirs(os.path.dirname(path), exist_ok=True)

    lines = [
        "# AUTOGENERATED: do not edit by hand",
        "# one 'deny <ip>;' per line",
        "",
    ]
    for ip in ips:
        lines.append(f"deny {ip};")
    lines.append("")  # trailing newline

    # Важно: пишем полностью и закрываем файл ДО reload (nginx читает include на reload)
    with open(path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))


def _reload_nginx() -> Tuple[bool, str | None]:
    token = _reloader_token()
    if not token:
        return False, "NGINX_RELOAD_TOKEN is empty (reload disabled)"

    url = _reloader_url().rstrip("/") + "/reload"
    try:
        r = httpx.post(url, headers={"X-Reload-Token": token}, timeout=10.0)
        if r.status_code >= 400:
            return False, f"{r.status_code}: {r.text}"
        return True, None
    except Exception as e:
        return False, str(e)


def sync_nginx_ban_file_and_reload(db: Session) -> None:
    """
    Перегенерирует ban_ips.conf из таблицы ban_ips и делает nginx reload через sidecar.
    """
    ips_raw = [ip for (ip,) in db.query(BanIP.ip).all()]
    ips: list[str] = []
    seen = set()
    for ip in ips_raw:
        ip_n = _norm_ip(ip)
        if not ip_n:
            continue
        if ip_n in seen:
            continue
        seen.add(ip_n)
        ips.append(ip_n)

    ips.sort()
    _write_ban_file(ips)

    ok, err = _reload_nginx()
    if not ok:
        if _reload_required():
            raise RuntimeError(f"nginx reload failed: {err}")
        logger.warning("nginx reload skipped/failed (non-fatal): %s", err)
        return


